class s{constructor(){this.judgeList=[]}add(s){this.judgeList.push(s)}remove(s){this.judgeList=this.judgeList.filter(e=>e.name!==s)}match(...s){var e=this.judgeList.map(e=>e.fun(s),[]),t=this.judgeList.map(s=>s);return new Promise(s=>{Promise.all(e).then(e=>{e.forEach((e,r)=>{e&&s(t[r].name)}),s("")})})}}class e{}class t{}class r{}class i{constructor(){this.storage=[]}get(s){return this.storage[s]}set(s,e){this.storage[s]=e}remove(s){this.storage[s]=void 0}clear(){this.storage=[]}}class n{constructor(){this.EventList=new Array}static getInstance(){return this.instance=this.instance||new n,this.instance}addEventListener(s,e){this.EventList.push({name:s,listener:e})}removeEventListener(s){this.EventList=this.EventList.filter(e=>e.name!==s)}dispatchEvent(s,e){this.EventList.filter(e=>e.name===s).map(s=>s.listener).forEach(s=>s(e))}}class a{constructor(){this.observers=[]}registerObserver(s){this.observers.push(s)}removeObserver(s){let e=this.observers.indexOf(s);-1!==e&&this.observers.splice(e,1)}notifyObservers(s,e=this.observers){for(let t of e)t.update(s)}}export{s as Auth,e as Error,n as EventDispatcher,t as Intercept,r as Log,a as ObserverSubject,i as Storage};
